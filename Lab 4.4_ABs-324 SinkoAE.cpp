// Lab 4.4_ABs-324 SinkoAE.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <random>
#include <vector>

using namespace std;	// использование стандартного пространства имен

void algorithm1(int round_number, vector<bool>& own, vector<bool>& enemy) {
// реализует простой алгоритм для игры в стратегию
// в стратегии игроки могут совершать действия, основываясь на предыдущих действиях противников
// round_number - номер текущего раунда,
// own - вектор, представляющий действия текущего игрока,
// enemy - вектор, представляющий действия противника.

	if (round_number == 0) {	// если это первый раунд
		// Сотрудничаем в первом раунде
		own.push_back(1);	// то игрок сотрудничает со стороны противника, добавляя true в вектор
	}
	else {	// если это не первый раунд
		// Предаем в остальных раундах
		own.push_back(0);	// то игрок предает, добавляя false в вектор
	}
}
// этот алгоритм всегда сотрудничает со стороны противника в первом раунде, а в остальных раундах всегда предает

void algorithm2(int round_number, vector<bool>& own, vector<bool>& enemy) {
// реализует алгоритм, который в каждом раунде случайным образом генерирует решение: сотрудничество (true) или предательство (false)
//round_number - номер текущего раунда,
// own - вектор, представляющий действия текущего игрока,
// enemy - вектор, представляющий действия противника.

	// Алгоритм для генерации чисел
	random_device rd;
	mt19937_64 gen(rd());
	uniform_int_distribution<> dist(0, 1);	// генерируется случайное число в диапазоне от 0 до 1
	own.push_back(dist(gen));	// результат (true или false) добавляется в вектор
}

void algorithm3(int round_number, vector<bool>& own, vector<bool>& enemy) {
//реализует алгоритм, который в зависимости от действий противника в предыдущем раунде сотрудничает или предает
//round_number - номер текущего раунда,
// own - вектор, представляющий действия текущего игрока,
// enemy - вектор, представляющий действия противника.

	// Если это не первый раунд и в предыдущем раунде противник не предал
	if (round_number > 0 && !enemy[round_number - 1]) {
		// то игрок сотрудничает со стороны противника, добавляя true в вектор
		own.push_back(1);
	}
	// Если это первый раунд или в предыдущем раунде противник предал
	else {
		// то игрок предает, добавляя false в вектор
		own.push_back(0);
	}
}

int main() {
	// Инициализация генератора случайных чисел
	random_device rd;
	mt19937_64 gen(rd());

	// Создание распределения для генерации случайного числа в диапазоне от 100 до 200 (количество раундов)
	uniform_int_distribution<> dist(100, 200);

	// Генерация случайного числа n в указанном диапазоне с помощью ранее созданного распределения и генератора
	int n = dist(gen);

	// Векторы для хранения действий первого и второго игроков соответственно
	vector<bool> first;
	vector<bool> second;

	// Переменные для подсчета очков игроков
	int check1 = 0;
	int check2 = 0;

	// Цикл, который выполняется n раз
	for (int i = 0; i < n; i++) {

		// Вызывается одна из комбинаций алгоритмов
		// 3 и 2 алгоритм
		algorithm3(i, first, second);
		algorithm2(i, second, first);

		// 2 и 1 алгоритм
		algorithm2(i, first, second);
		algorithm1(i, second, first);

		// 1 и 3 алгоритм
		algorithm3(i, first, second);
		algorithm2(i, second, first);

		// Проверяется, какие действия совершили игроки в текущем раунде и начисляются очки в соответствии с правилами игры
		if (first[i] && second[i]) {	// оба выбирают сотрудничество
			check1 += 24;
			check2 += 24;
		}
		else if (first[i] && !(second[i])) {	// сотрудничество и предательство
			check1 += 0;
			check2 += 20;
		}
		else if (!first[i] && (second[i])) {	// предательство и сотрудничество
			check1 += 20;
			check2 += 0;
		}
		else if (!first[i] && !(second[i])) {	// оба предательство
			check1 += 4;
			check2 += 4;
		}

		// Вывод на экран текущих действий игроков и их очков
		cout << first[i] << " " << second[i] << " " << check1 << " " << check2 << endl;
	}

	return 0;
}