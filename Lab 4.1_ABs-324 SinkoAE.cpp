// Lab 4.1_ABs-324 SinkoAE.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <math.h>
#include <vector>
#include <iomanip>
#include <locale.h> //подключение библиотеки для задач связанных из локализацией

using namespace std;	// пространство имен std

const double E = 0.0001;	// заданная точность вычислений по условию

// Функция 𝑥 𝑙𝑛(𝑥 + 1) = 1 (в соответствии с вариантом)
double f(double x) {
	return (x * log(x + 1) - 1);
}

// Производная функции f(x)
double f1(double x) {
	return x / (x + 1) + log(x + 1);
}

// Метод половинного деления
// основан на интервале, в котором предполагается находится корень.

int halfDivision(double a, double b, vector<double>& roots) {

	// Проверка, что корень находится в пределах отрезка [a, b]
	if (f(a) * f(b) >= 0.0) {
		cout << "Неверный интервал" << endl;
		return 0;
	}
	// Если значения функции f(a) и f(b) одного знака, то на этом отрезке не может быть корня, поэтому выводится сообщение об ошибке и функция возвращает 0.

	int k = 0;	// счетчик итераций
	double c = 0;	// вспомогательная переменная для хранения середины текущего интервала

	// Цикл, который будет выполняться до тех пор, пока длина текущего интервала не станет меньше заданной точности E
	while (abs(b - a) >= E) {

		// Вывод на экран номера итерации, текущих границ интервала и их разницы
		cout << setw(7) << k << "|" << setw(8) << fixed << setprecision(4) << a << " | " << setw(8) << b << "|" << b - a << endl;

		c = (a + b) / 2;	// вычисление середины текущего интервала

		if (f(c) == 0.0) {	// если функция f(c) обращается в ноль в точке c
			break;	// то корень найден, и цикл прерывается
		}
		else if (f(c) * f(a) < 0) {	// если произведение f(c) и f(a) меньше нуля
			b = c;	// то корень находится в левой половине интервала, поэтому правая граница обновляется
		}
		else {	// в противном случае
			a = c;	// корень находится в правой половине интервала, поэтому левая граница обновляется
		}
		k++;	// увеличение счетчика итераций
	}

	roots.push_back(c);	// добавление найденного корня в вектор

	// Вывод на экран найденного корня и количества итераций
	cout << "Корень " << c << " с " << k << " итерациями" << endl;

	return k;	// возврат количества итераций, за которое был найден корень
}

// Метод Ньютона
// итерационный метод численного решения нелинейных уравнений
// Итерационный процесс основан на формуле:
// x[n+1] = x[n] - f(x[n]) / f'(x[n]),
// где x[n+1] - новое приближение корня,
// x[n] - текущее приближение,
// f(x[n]) - значение функции в точке x[n],
// f'(x[n]) - значение производной функции в точке x[n].

int newtonMethod(double x0, vector<double>& roots) {

	int k = 0;	// инициализация счетчика итераций k
	double x1 = x0 - f(x0) / f1(x0);	// вычисление первого приближения корня

	// Цикл, который будет выполняться до тех пор, пока разница между двумя последовательными приближениями корня не станет меньше заданной точности E
	while (abs(x1 - x0) >= E) {

		// Вывод на экран номера итерации, текущего приближения и разницы между текущим и предыдущим приближением
		cout << setw(7) << k << "|" << setw(8) << fixed << setprecision(4) << x0 << " | " << setw(8) << x1 << "|" << x1 - x0 << endl;

		x0 = x1;	// обновление предыдущего приближения
		x1 = x0 - f(x0) / f1(x0);	// вычисление нового приближения корня
		k++;	// увеличение счетчика итераций
	}

	roots.push_back(x0);	// добавление найденного корня в вектор

	// Вывод на экран найденного корня и количества итераций
	cout << "Корень " << x0 << " с " << k << " итерациями" << endl;

	return k;	// возврат количества итераций, за которое был найден корень
}

// Метод простых итераций
// итерационный метод численного решения уравнений вида x = φ(x), где φ(x) - некоторая функция, удовлетворяющая условиям сходимости итерационного процесса.
// Итерационный процесс продолжается до тех пор, пока не будет достигнута требуемая точность.

int simpleIterations(double x0, vector<double>& roots) {

	int k = 0;	// инициализация счетчика итераций k

	double x1 = 1 / log(x0 + 1);	// вычисление первого приближения корня методом простых итераций. В данном случае, φ(x) = 1 / ln(x + 1)

	// Цикл, который будет выполняться до тех пор, пока разница между двумя последовательными приближениями корня не станет меньше заданной точности E
	while (abs(x1 - x0) > E) {

		// Вывод на экран номера итерации, текущего приближения и разницы между текущим и предыдущим приближением
		cout << setw(7) << k << "|" << setw(8) << fixed << setprecision(4) << x0 << " | " << setw(8) << x1 << "|" << x1 - x0 << endl;

		x0 = x1;	// обновление предыдущего приближения
		x1 = 1 / log(x0 + 1);	// вычисление нового приближения корня
		k++;	// увеличение счетчика итераций
	}

	roots.push_back(x0);	// добавление найденного корня в вектор

	// Вывод на экран найденного корня и количества итераций
	cout << "Корень " << x0 << " с " << k << " итерациями" << endl;

	return k;	// возврат количества итераций, за которое был найден корень
}

int main() {
	setlocale(LC_ALL, "rus");   //установка русской локали

	// Вывод сообщения на экран о начале процесса уточнения корня методом половинного деления
	cout << "Процесс уточнения корня методом половинного деления с точностью до E" << endl;

	vector<double> roots;	// объявление вектора roots для хранения найденных корней

	// Вызов функции halfDivision для нахождения корня методом половинного деления в интервале от -1 до 1.
	// Результат (количество итераций) сохраняется в переменной s1.
	int s1 = halfDivision(-1, 1, roots);

	// Вывод сообщения на экран о начале процесса уточнения корня методом Ньютона
	cout << endl << "Процесс уточнения корня методом Ньютона с точностью до E" << endl;

	// Вызов функции newtonMethod для нахождения корня методом Ньютона, используя начальное приближение 10.
	// Результат (количество итераций) сохраняется в переменной s2.
	int s2 = newtonMethod(10, roots);

	// Вывод сообщения на экран о начале процесса уточнения корня методом простых итераций
	cout << endl << "Процесс уточнения корня методом простых итераций с точностью до E" << endl;

	// Вызов функции simpleIterations для нахождения корня методом простых итераций, используя начальное приближение 2.
	// Результат (количество итераций) сохраняется в переменной s3.
	int s3 = simpleIterations(2, roots);

	// Вывод сообщения на экран о выводе всех найденных корней
	cout << endl << "Все найденные корни уравнения" << endl;

	// Цикл, который проходит по всем элементам вектора roots и выводит их на экран
	for (double i : roots) {
		cout << i << " ";
	}

	// Вывод сообщения на экран о скорости сходимости методов
	cout << endl << "Скорости сходимости: " << endl;

	// Вывод количества итераций, за которое был найден корень методом половинного деления
	cout << endl << "метод половинного деления: " << s1 << " итераций" << endl;

	// Вывод количества итераций, за которое был найден корень методом Ньютона
	cout << endl << "метод Ньютона: " << s2 << " итераций" << endl;

	// Вывод количества итераций, за которое был найден корень методом простых итераций
	cout << endl << "метод простых итераций: " << s3 << " итераций" << endl;
	
}